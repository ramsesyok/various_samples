# アサーションマクロ

多くのテストフレームワークでは、すべての条件形式をカバーするために多数のアサーションマクロ（`_EQUALS`、`_NOTEQUALS`、`_GREATER_THAN` など）を提供しています。

Catch は異なります。Catch は C スタイルの自然な条件式を分解できるため、これらの形式のほとんどは、1〜2 種類のマクロで済みます。とはいえ、補助的なマクロも豊富に用意されています。ここではそれらすべてを解説します。

これらのマクロの多くは、2 つの形式で提供されています。

---

## 自然な式の記述

`REQUIRE` 系のマクロは式を評価し、失敗した場合はそのテストケースを中断します。  
`CHECK` 系のマクロは `REQUIRE` と同じですが、失敗してもそのまま同じテストケースの実行を続行します。独立したアサーションを複数記述した場合に、それぞれの結果をすべて確認したいときに便利です。

* **REQUIRE(** _式_ **)**  
* **CHECK(** _式_ **)**

式を評価し、結果を記録します。例外が投げられた場合、それは捕捉・報告され、失敗としてカウントされます。これらは最も頻繁に使うマクロです。

例：
```
CHECK( str == "string value" );
CHECK( thisReturnsTrue() );
REQUIRE( i == 42 );
```

* **REQUIRE_FALSE(** _式_ **)**  
* **CHECK_FALSE(** _式_ **)**

式を評価し、その論理否定（NOT）の結果を記録します。例外が投げられた場合は同様に捕捉・報告され、失敗としてカウントされます。  
（これは `!` を前置した式が分解できないことへのワークアラウンドとして用意されています）

例：
```
REQUIRE_FALSE( thisReturnsFalse() );
```

注意：複雑すぎる式は分解できないため、コンパイルエラーになります。これは実用的な理由（式テンプレートの簡素化）と設計思想（アサーションは単純かつ決定的であるべき）によるものです。

例：

- `CHECK(a == 1 && b == 2);`  
  この式は `&&` により複雑すぎます。2つ以上の条件をチェックしたい場合は、次のいずれかにしてください：  
     - 式を括弧で囲んで分解を防ぐ（デバッグ情報が減る）  
     - 式を複数のアサーションに分ける：  
        `CHECK( a == 1 ); CHECK( b == 2 );`
- `CHECK( a == 2 || b == 1 );`  
この式も `||` により複雑です。1つでも成立していれば良いという条件にしたい場合は、括弧で囲んで分解を防ぎましょう（この場合、複数の `CHECK` に分けることはできません）。

---

### 浮動小数点比較

浮動小数点数を比較する場合（特に計算結果同士など）、丸め誤差や表現の不正確さに注意が必要です。

Catch は `Approx` クラスを使って許容誤差付きの比較を行えます。`Approx` は比較演算子をオーバーロードしており、両辺のいずれかに使えます。以下は簡単な例です：

```cpp
REQUIRE( performComputation() == Approx( 2.1 ) );
```

また、Catch では `Approx` 用のユーザー定義リテラル `_a` も用意されています。これは `Catch::literals` 名前空間にあり、以下のように使えます：

```cpp
using namespace Catch::literals;
REQUIRE( performComputation() == 2.1_a );
```

`Approx` は一般的な用途に対応できるよう、デフォルトの設定を持っていますが、以下の 3 つのカスタマイズポイントがあります：

* __epsilon__ - 結果が `Approx` の値からどれだけ相対的にズレていても許容されるかを指定します。  
  _デフォルトは `std::numeric_limits<float>::epsilon() * 100`_
* __margin__ - 絶対値としてどれだけズレていても許容されるかを指定します。  
  _デフォルトは `0.0`_
* __scale__ - 相対誤差の計算時に `Approx` のスケールを調整できます。  
  _デフォルトは `0.0`_

#### epsilon の例
```cpp
Approx target = Approx(100).epsilon(0.01);
100.0 == target; // 明らかに true
200.0 == target; // 明らかに false
100.5 == target; // true（1% までの誤差を許容）
```

#### margin の例
```cpp
Approx target = Approx(100).margin(5);
100.0 == target; // 明らかに true
200.0 == target; // 明らかに false
104.0 == target; // true（±5 の範囲を許容）
```

#### scale の使い所
計算と比較のスケールが異なる場合に使います。`Approx` の値を基準に `(scale + value) * epsilon` で誤差が計算されるため、場合によってはスケーリングが必要になります。

---

## 例外

* **REQUIRE_NOTHROW(** _式_ **)**  
* **CHECK_NOTHROW(** _式_ **)**  
  - 式の評価中に例外が「発生しない」ことを期待します。

* **REQUIRE_THROWS(** _式_ **)**  
* **CHECK_THROWS(** _式_ **)**  
  - 任意の型の例外が「発生する」ことを期待します。

* **REQUIRE_THROWS_AS(** _式_, _例外型_ **)**  
* **CHECK_THROWS_AS(** _式_, _例外型_ **)**  
  - 指定した型の例外が発生することを期待します（型は `const&` で自動補完されるので、明示しないでください）。

* **REQUIRE_THROWS_WITH(** _式_, _文字列またはマッチャー_ **)**  
* **CHECK_THROWS_WITH(** _式_, _文字列またはマッチャー_ **)**  
  - 例外が発生し、その `what()` メッセージが指定した文字列またはマッチャーに一致することを期待します。

例：
```cpp
REQUIRE_THROWS_WITH( openThePodBayDoors(), Contains( "afraid" ) && Contains( "can't do that" ) );
REQUIRE_THROWS_WITH( dismantleHal(), "My mind is going" );
```

* **REQUIRE_THROWS_MATCHES(** _式_, _例外型_, _マッチャー_ **)**  
* **CHECK_THROWS_MATCHES(** _式_, _例外型_, _マッチャー_ **)**  
  - 指定した型の例外が発生し、マッチャーに一致することを期待します（[マッチャーの詳細はこちら](matchers.md)）。

⚠️ `THROW` 系のマクロには「単一の式」を渡す必要があります。複数ステートメントを評価したい場合は、C++11 のラムダ式を使ってください。

```cpp
REQUIRE_NOTHROW([&](){
    int i = 1;
    int j = 2;
    auto k = i + j;
    if (k == 3) {
        throw 1;
    }
}());
```

---

## マッチャー式

マッチャーを使うには、少し異なる形式のマクロを使用します。マッチャーに関しては [専用のドキュメント](matchers.md) を参照してください。

* **REQUIRE_THAT(** _lhs_, _マッチャー式_ **)**  
* **CHECK_THAT(** _lhs_, _マッチャー式_ **)**

マッチャーは `&&`、`||`、`!` を使って合成することができます。

---

## スレッドセーフティ

現在、Catch におけるアサーションはスレッドセーフではありません。  
詳細と回避策については、[制限事項の該当セクション](./limitations.md#thread-safe-assertions) を参照してください。

---

## カンマを含む式

プリプロセッサはコンパイラとは異なる規則でコードを解析するため、複数引数のアサーションマクロ（例：`REQUIRE_THROWS_AS`）にカンマを含む式を渡すと問題が発生します。

例：  
`REQUIRE_THROWS_AS(std::pair<int, int>(1, 2), std::invalid_argument);`  
は、プリプロセッサには3引数に見えるため、2引数のマクロではコンパイルエラーになります。

次の2つの回避策があります：

1) **typedef を使う**
```cpp
using int_pair = std::pair<int, int>;
REQUIRE_THROWS_AS(int_pair(1, 2), std::invalid_argument);
```

常に使えますが、コードの意図がわかりにくくなる場合があります。

2) **括弧で囲む**
```cpp
TEST_CASE_METHOD((Fixture<int, int>), "foo", "[bar]") {
    SUCCEED();
}
```

この方法は常に使えるわけではなく、Catch 側の追加対応が必要な場合があります。

---

[ホームへ戻る](Readme.md)

